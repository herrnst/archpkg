From abde4d09a1831467a237851ce97be58422bee817 Mon Sep 17 00:00:00 2001
From: Asahi Lina <lina@asahilina.net>
Date: Fri, 10 May 2024 20:39:00 +0900
Subject: [PATCH] asahi: Update to UAPI 10011

Incompatible changes:
- Make VM layout more flexible to allow for SVM with rusticl
  (eventually, hopefully)

Compatible changes:
- Expose soft fault state to userspace as a flag
---
 include/drm-uapi/asahi_drm.h         | 19 ++++++++++++-----
 src/asahi/drm-shim/asahi_noop.c      |  4 ++--
 src/asahi/lib/agx_device.c           | 32 ++++++++++++++++++++++------
 src/gallium/drivers/asahi/agx_pipe.c |  4 ++++
 4 files changed, 45 insertions(+), 14 deletions(-)

diff --git a/include/drm-uapi/asahi_drm.h b/include/drm-uapi/asahi_drm.h
index be8cfef1d91b7..af2e8b5801b53 100644
--- a/include/drm-uapi/asahi_drm.h
+++ b/include/drm-uapi/asahi_drm.h
@@ -16,7 +16,7 @@
 extern "C" {
 #endif
 
-#define DRM_ASAHI_UNSTABLE_UABI_VERSION		10010
+#define DRM_ASAHI_UNSTABLE_UABI_VERSION		10011
 
 #define DRM_ASAHI_GET_PARAMS			0x00
 #define DRM_ASAHI_VM_CREATE			0x01
@@ -55,8 +55,9 @@ struct drm_asahi_params_global {
 	__u32 pad1;
 	__u64 vm_user_start;
 	__u64 vm_user_end;
-	__u64 vm_shader_start;
-	__u64 vm_shader_end;
+	__u64 vm_usc_start;
+	__u64 vm_usc_end;
+	__u64 vm_kernel_min_size;
 
 	__u32 max_syncs_per_submission;
 	__u32 max_commands_per_submission;
@@ -74,10 +75,9 @@ struct drm_asahi_params_global {
 	__u32 firmware_version[4];
 };
 
-/*
 enum drm_asahi_feat_compat {
+	DRM_ASAHI_FEAT_SOFT_FAULTS = (1UL) << 0,
 };
-*/
 
 enum drm_asahi_feat_incompat {
 	DRM_ASAHI_FEAT_MANDATORY_ZS_COMPRESSION = (1UL) << 0,
@@ -104,6 +104,12 @@ struct drm_asahi_vm_create {
 	/** @extensions: Pointer to the first extension struct, if any */
 	__u64 extensions;
 
+	/** @kernel_start: Start of the kernel-reserved address range */
+	__u64 kernel_start;
+
+	/** @kernel_end: End of the kernel-reserved address range */
+	__u64 kernel_end;
+
 	/** @value: Returned VM ID */
 	__u32 vm_id;
 
@@ -344,6 +350,8 @@ struct drm_asahi_cmd_render {
 	__u64 flags;
 
 	__u64 encoder_ptr;
+	__u64 vertex_usc_base;
+	__u64 fragment_usc_base;
 
 	__u64 vertex_attachments;
 	__u64 fragment_attachments;
@@ -507,6 +515,7 @@ struct drm_asahi_cmd_compute {
 
 	__u64 encoder_ptr;
 	__u64 encoder_end;
+	__u64 usc_base;
 
 	__u64 attachments;
 	__u32 attachment_count;
diff --git a/src/asahi/drm-shim/asahi_noop.c b/src/asahi/drm-shim/asahi_noop.c
index 2703c7c6e0956..4dd56f5f25419 100644
--- a/src/asahi/drm-shim/asahi_noop.c
+++ b/src/asahi/drm-shim/asahi_noop.c
@@ -18,8 +18,8 @@ static const struct drm_asahi_params_global params = {
    .gpu_revision = 0,
    .vm_user_start = 0x1000000,
    .vm_user_end = 0x5000000,
-   .vm_shader_start = 0x8000000,
-   .vm_shader_end = 0x9000000,
+   .vm_usc_start = 0,
+   .vm_usc_end = 0,
    .vm_page_size = 4096,
 };
 
diff --git a/src/asahi/lib/agx_device.c b/src/asahi/lib/agx_device.c
index 8b59756914612..3c5e72d2bea92 100644
--- a/src/asahi/lib/agx_device.c
+++ b/src/asahi/lib/agx_device.c
@@ -526,7 +526,19 @@ agx_open_device(void *memctx, struct agx_device *dev)
    }
 
    dev->guard_size = dev->params.vm_page_size;
-   dev->shader_base = dev->params.vm_shader_start;
+   if (dev->params.vm_usc_start) {
+      dev->shader_base = dev->params.vm_usc_start;
+   } else {
+      // Put the USC heap at the bottom of the user address space, 4GiB aligned
+      dev->shader_base = ALIGN_POT(dev->params.vm_user_start, 0x100000000ull);
+   }
+
+   uint64_t shader_size = 0x100000000ull;
+   // Put the user heap after the USC heap
+   uint64_t user_start = dev->shader_base + shader_size;
+
+   assert(dev->shader_base >= dev->params.vm_user_start);
+   assert(user_start < dev->params.vm_user_end);
 
    util_sparse_array_init(&dev->bo_map, sizeof(struct agx_bo), 512);
    pthread_mutex_init(&dev->bo_map_lock, NULL);
@@ -537,7 +549,16 @@ agx_open_device(void *memctx, struct agx_device *dev)
    for (unsigned i = 0; i < ARRAY_SIZE(dev->bo_cache.buckets); ++i)
       list_inithead(&dev->bo_cache.buckets[i]);
 
-   struct drm_asahi_vm_create vm_create = {};
+   // Put the kernel heap at the top of the address space.
+   // Give it 32GB of address space, should be more than enough for any
+   // reasonable use case.
+   uint64_t kernel_size = MAX2(dev->params.vm_kernel_min_size, 32ull << 30);
+   struct drm_asahi_vm_create vm_create = {
+      .kernel_start = dev->params.vm_user_end - kernel_size,
+      .kernel_end = dev->params.vm_user_end,
+   };
+
+   uint64_t user_size = vm_create.kernel_start - user_start;
 
    int ret = asahi_simple_ioctl(dev, DRM_IOCTL_ASAHI_VM_CREATE, &vm_create);
    if (ret) {
@@ -547,11 +568,8 @@ agx_open_device(void *memctx, struct agx_device *dev)
    }
 
    simple_mtx_init(&dev->vma_lock, mtx_plain);
-   util_vma_heap_init(&dev->main_heap, dev->params.vm_user_start,
-                      dev->params.vm_user_end - dev->params.vm_user_start + 1);
-   util_vma_heap_init(
-      &dev->usc_heap, dev->params.vm_shader_start,
-      dev->params.vm_shader_end - dev->params.vm_shader_start + 1);
+   util_vma_heap_init(&dev->main_heap, user_start, user_size);
+   util_vma_heap_init(&dev->usc_heap, dev->shader_base, shader_size);
 
    dev->vm_id = vm_create.vm_id;
 
diff --git a/src/gallium/drivers/asahi/agx_pipe.c b/src/gallium/drivers/asahi/agx_pipe.c
index ff7604e0ef635..77e52dd0c3f06 100644
--- a/src/gallium/drivers/asahi/agx_pipe.c
+++ b/src/gallium/drivers/asahi/agx_pipe.c
@@ -1284,6 +1284,9 @@ agx_cmdbuf(struct agx_device *dev, struct drm_asahi_cmd_render *c,
    c->cmd_3d_id = cmd_3d_id;
    c->cmd_ta_id = cmd_ta_id;
 
+   c->fragment_usc_base = dev->shader_base;
+   c->vertex_usc_base = dev->shader_base;
+
    /* bit 0 specifies OpenGL clip behaviour. Since ARB_clip_control is
     * advertised, we don't set it and lower in the vertex shader.
     */
@@ -1607,6 +1610,7 @@ agx_flush_compute(struct agx_context *ctx, struct agx_batch *batch,
       .encoder_ptr = batch->cdm.bo->ptr.gpu,
       .encoder_end = batch->cdm.bo->ptr.gpu +
                      (batch->cdm.current - (uint8_t *)batch->cdm.bo->ptr.cpu),
+      .usc_base = dev->shader_base,
       .helper_arg = 0,
       .helper_cfg = 0,
       .helper_program = 0,
-- 
GitLab

